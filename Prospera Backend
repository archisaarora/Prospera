# v3
import os
import spacy
from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

# Initialize spaCy model
nlp = spacy.load('en_core_web_md')

# Define the directory where text files are stored
DOCS_DIR = "ProsperaDocuments"


# Function to read all text files from the directory and create the documents list
def load_documents_from_folder(folder_path):
    documents = []
    for filename in os.listdir(folder_path):
        if filename.endswith(".txt"):  # Only process .txt files
            file_path = os.path.join(folder_path, filename)
            with open(file_path, "r", encoding="utf-8") as file:
                content = file.read()
                documents.append({"doc_name": filename, "content": content})
    return documents


# Load documents from the folder
documents = load_documents_from_folder(DOCS_DIR)


@app.route("/")
def home():
    return "Welcome to Prospera!"


@app.route("/process_query", methods=["POST"])
def process_query():
    data = request.get_json()
    query = data.get('query', '')

    # If query is empty, return an error
    if not query:
        return jsonify({"error": "No query provided"}), 400

    # Process the query using spaCy to get its vector representation (semantic understanding)
    query_doc = nlp(query)

    query_vector = query_doc.vector  # This is the query's vector representation

    results = []

    # Loop through each document
    for doc in documents:
        doc_content = doc["content"]
        doc_name = doc["doc_name"]

        # Process the document to get its vector representation
        doc_parsed = nlp(doc_content)
        doc_vector = doc_parsed.vector  # This is the document's vector representation

        # Calculate cosine similarity between query and document vectors
        similarity = query_doc.similarity(
            doc_parsed)  # Direct comparison between vectors

        # Check if the query keyword appears in the document title or content (boost similarity)
        if query.lower() in doc_name.lower() or query.lower(
        ) in doc_content.lower():
            similarity *= 1.5  # Boost the similarity score (you can adjust this factor)

        # Find the most relevant sentences by checking cosine similarity with each sentence
        relevant_sentences = []
        for sentence in doc_parsed.sents:
            sentence_similarity = query_doc.similarity(
                sentence)  # Compare sentence with the query
            if sentence_similarity > 0.5:  # Adjust the threshold based on relevance
                relevant_sentences.append({
                    "sentence": sentence.text,
                    "similarity": sentence_similarity
                })

        if relevant_sentences:
            results.append({
                "query":
                query,
                "doc_name":
                doc_name,
                "similarity":
                similarity,
                "relevant_sentences":
                sorted(relevant_sentences,
                       key=lambda x: x["similarity"],
                       reverse=True)[:3]  # Top 3 relevant sentences
            })

    # Sort results by overall similarity between query and document
    sorted_results = sorted(results,
                            key=lambda x: x['similarity'],
                            reverse=True)[:3]

    # Return the most relevant documents with their sentences
    return jsonify({"keywords": sorted_results})


@app.route("/get_full_text", methods=["GET"])
def get_full_text():
    doc_name = request.args.get(
        'doc_name')  # Get the document name from query parameter

    # If doc_name is not provided, return an error
    if not doc_name:
        return jsonify({'error': 'Document name is required'}), 400

    # Search for the document in the loaded documents list
    document = next((doc for doc in documents if doc['doc_name'] == doc_name),
                    None)
    if document:
        # Return the full content of the document
        return jsonify({'fullText': document['content']})
    else:
        return jsonify({'error': 'Document not found'}), 404


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
